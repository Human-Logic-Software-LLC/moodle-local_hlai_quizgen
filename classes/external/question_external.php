<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.

/**
 * External API for question CRUD operations in the AI Quiz Generator plugin.
 *
 * Provides web service functions for updating, approving, rejecting, and
 * reordering questions and answers generated by the plugin.
 *
 * @package    local_hlai_quizgen
 * @copyright  2025 Human Logic Software LLC
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace local_hlai_quizgen\external;

/**
 * Question external API class.
 *
 * Implements external web service functions for question and answer
 * management including inline editing, approval workflows, and bulk operations.
 *
 * @package    local_hlai_quizgen
 * @copyright  2025 Human Logic Software LLC
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class question_external extends \external_api {
    // -------------------------------------------------------------------------
    // 1. update_question
    // -------------------------------------------------------------------------

    /**
     * Describes the parameters for update_question.
     *
     * @return \external_function_parameters
     */
    public static function update_question_parameters() {
        return new \external_function_parameters([
            'questionid' => new \external_value(PARAM_INT, 'The question ID', VALUE_REQUIRED),
            'field' => new \external_value(PARAM_TEXT, 'The field to update', VALUE_REQUIRED),
            'value' => new \external_value(PARAM_TEXT, 'The new value for the field', VALUE_REQUIRED),
        ]);
    }

    /**
     * Update a single field on a question record.
     *
     * Validates that the current user owns the question and that the field
     * is in the allowed list before performing the update.
     *
     * @param int    $questionid The question ID.
     * @param string $field      The field name to update.
     * @param string $value      The new value.
     * @return array The updated field and value.
     */
    public static function update_question($questionid, $field, $value) {
        global $DB, $USER;

        // Validate parameters.
        $params = self::validate_parameters(self::update_question_parameters(), [
            'questionid' => $questionid,
            'field' => $field,
            'value' => $value,
        ]);
        $questionid = $params['questionid'];
        $field = $params['field'];
        $value = $params['value'];

        // Get the question record.
        $question = $DB->get_record('local_hlai_quizgen_questions', ['id' => $questionid], '*', MUST_EXIST);

        // Validate ownership.
        if ($question->userid != $USER->id) {
            throw new \moodle_exception('nopermissions', 'error');
        }

        // Validate context.
        $request = $DB->get_record('local_hlai_quizgen_requests', ['id' => $question->requestid], '*', MUST_EXIST);
        $context = \context_course::instance($request->courseid);
        self::validate_context($context);

        // Validate the field is allowed.
        $allowedfields = ['questiontext', 'difficulty', 'blooms_level', 'generalfeedback'];
        if (!in_array($field, $allowedfields)) {
            throw new \moodle_exception('ajax_invalid_field', 'local_hlai_quizgen');
        }

        // Sanitize based on field type.
        if ($field === 'questiontext' || $field === 'generalfeedback') {
            $value = clean_param($value, PARAM_TEXT);
        } else {
            $value = clean_param($value, PARAM_ALPHANUMEXT);
        }

        // Perform the update.
        $DB->set_field('local_hlai_quizgen_questions', $field, $value, ['id' => $questionid]);
        $DB->set_field('local_hlai_quizgen_questions', 'timemodified', time(), ['id' => $questionid]);

        return [
            'field' => $field,
            'value' => $value,
        ];
    }

    /**
     * Describes the return value for update_question.
     *
     * @return \external_single_structure
     */
    public static function update_question_returns() {
        return new \external_single_structure([
            'field' => new \external_value(PARAM_TEXT, 'The updated field name'),
            'value' => new \external_value(PARAM_TEXT, 'The updated value'),
        ]);
    }

    // -------------------------------------------------------------------------
    // 2. update_answer
    // -------------------------------------------------------------------------

    /**
     * Describes the parameters for update_answer.
     *
     * @return \external_function_parameters
     */
    public static function update_answer_parameters() {
        return new \external_function_parameters([
            'answerid' => new \external_value(PARAM_INT, 'The answer ID', VALUE_REQUIRED),
            'field' => new \external_value(PARAM_TEXT, 'The field to update', VALUE_REQUIRED),
            'value' => new \external_value(PARAM_TEXT, 'The new value for the field', VALUE_REQUIRED),
        ]);
    }

    /**
     * Update a single field on an answer record.
     *
     * Validates that the current user owns the parent question and that
     * the field is in the allowed list before performing the update.
     *
     * @param int    $answerid The answer ID.
     * @param string $field    The field name to update.
     * @param string $value    The new value.
     * @return array The updated field and value.
     */
    public static function update_answer($answerid, $field, $value) {
        global $DB, $USER;

        // Validate parameters.
        $params = self::validate_parameters(self::update_answer_parameters(), [
            'answerid' => $answerid,
            'field' => $field,
            'value' => $value,
        ]);
        $answerid = $params['answerid'];
        $field = $params['field'];
        $value = $params['value'];

        // Get the answer and parent question records.
        $answer = $DB->get_record('local_hlai_quizgen_answers', ['id' => $answerid], '*', MUST_EXIST);
        $question = $DB->get_record('local_hlai_quizgen_questions', ['id' => $answer->questionid], '*', MUST_EXIST);

        // Validate ownership.
        if ($question->userid != $USER->id) {
            throw new \moodle_exception('nopermissions', 'error');
        }

        // Validate context.
        $request = $DB->get_record('local_hlai_quizgen_requests', ['id' => $question->requestid], '*', MUST_EXIST);
        $context = \context_course::instance($request->courseid);
        self::validate_context($context);

        // Validate the field is allowed.
        $allowedfields = ['answer', 'feedback', 'fraction'];
        if (!in_array($field, $allowedfields)) {
            throw new \moodle_exception('ajax_invalid_field', 'local_hlai_quizgen');
        }

        // Sanitize based on field type.
        if ($field === 'fraction') {
            $value = (string)(float)$value;
        } else {
            $value = clean_param($value, PARAM_TEXT);
        }

        // Perform the update.
        $DB->set_field('local_hlai_quizgen_answers', $field, $value, ['id' => $answerid]);

        return [
            'field' => $field,
            'value' => $value,
        ];
    }

    /**
     * Describes the return value for update_answer.
     *
     * @return \external_single_structure
     */
    public static function update_answer_returns() {
        return new \external_single_structure([
            'field' => new \external_value(PARAM_TEXT, 'The updated field name'),
            'value' => new \external_value(PARAM_TEXT, 'The updated value'),
        ]);
    }

    // -------------------------------------------------------------------------
    // 3. reorder_answers
    // -------------------------------------------------------------------------

    /**
     * Describes the parameters for reorder_answers.
     *
     * @return \external_function_parameters
     */
    public static function reorder_answers_parameters() {
        return new \external_function_parameters([
            'questionid' => new \external_value(PARAM_INT, 'The question ID', VALUE_REQUIRED),
            'order' => new \external_value(PARAM_RAW, 'JSON array of answer IDs in new order', VALUE_REQUIRED),
        ]);
    }

    /**
     * Reorder the answers for a question (drag and drop support).
     *
     * Accepts a JSON-encoded array of answer IDs and updates the sortorder
     * for each answer belonging to the specified question.
     *
     * @param int    $questionid The question ID.
     * @param string $order      JSON-encoded array of answer IDs.
     * @return array The count of reordered answers.
     */
    public static function reorder_answers($questionid, $order) {
        global $DB, $USER;

        // Validate parameters.
        $params = self::validate_parameters(self::reorder_answers_parameters(), [
            'questionid' => $questionid,
            'order' => $order,
        ]);
        $questionid = $params['questionid'];
        $order = $params['order'];

        // Get the question record.
        $question = $DB->get_record('local_hlai_quizgen_questions', ['id' => $questionid], '*', MUST_EXIST);

        // Validate ownership.
        if ($question->userid != $USER->id) {
            throw new \moodle_exception('nopermissions', 'error');
        }

        // Validate context.
        $request = $DB->get_record('local_hlai_quizgen_requests', ['id' => $question->requestid], '*', MUST_EXIST);
        $context = \context_course::instance($request->courseid);
        self::validate_context($context);

        // Decode the JSON order array.
        $order = json_decode($order, true);
        if (!is_array($order)) {
            throw new \moodle_exception('ajax_invalid_order_format', 'local_hlai_quizgen');
        }

        // Update sortorder for each answer.
        foreach ($order as $sortorder => $answerid) {
            $DB->set_field('local_hlai_quizgen_answers', 'sortorder', $sortorder, [
                'id' => (int)$answerid,
                'questionid' => $questionid,
            ]);
        }

        return [
            'reordered' => count($order),
        ];
    }

    /**
     * Describes the return value for reorder_answers.
     *
     * @return \external_single_structure
     */
    public static function reorder_answers_returns() {
        return new \external_single_structure([
            'reordered' => new \external_value(PARAM_INT, 'Number of answers reordered'),
        ]);
    }

    // -------------------------------------------------------------------------
    // 4. approve_question
    // -------------------------------------------------------------------------

    /**
     * Describes the parameters for approve_question.
     *
     * @return \external_function_parameters
     */
    public static function approve_question_parameters() {
        return new \external_function_parameters([
            'questionid' => new \external_value(PARAM_INT, 'The question ID', VALUE_REQUIRED),
            'confidence' => new \external_value(PARAM_INT, 'Confidence rating (0-5)', VALUE_DEFAULT, 0),
        ]);
    }

    /**
     * Approve a question with an optional confidence rating.
     *
     * Sets the question status to 'approved' and logs the approval action
     * with the provided confidence level if it is between 1 and 5.
     *
     * @param int $questionid The question ID.
     * @param int $confidence Optional confidence rating (1-5).
     * @return array The new status.
     */
    public static function approve_question($questionid, $confidence = 0) {
        global $DB, $USER;

        // Validate parameters.
        $params = self::validate_parameters(self::approve_question_parameters(), [
            'questionid' => $questionid,
            'confidence' => $confidence,
        ]);
        $questionid = $params['questionid'];
        $confidence = $params['confidence'];

        // Get the question record.
        $question = $DB->get_record('local_hlai_quizgen_questions', ['id' => $questionid], '*', MUST_EXIST);

        // Validate ownership.
        if ($question->userid != $USER->id) {
            throw new \moodle_exception('nopermissions', 'error');
        }

        // Validate context.
        $request = $DB->get_record('local_hlai_quizgen_requests', ['id' => $question->requestid], '*', MUST_EXIST);
        $context = \context_course::instance($request->courseid);
        self::validate_context($context);

        // Update the question status.
        $DB->set_field('local_hlai_quizgen_questions', 'status', 'approved', ['id' => $questionid]);
        $DB->set_field('local_hlai_quizgen_questions', 'timemodified', time(), ['id' => $questionid]);

        // Log approval with confidence if provided.
        if ($confidence > 0 && $confidence <= 5) {
            $DB->insert_record('local_hlai_quizgen_logs', [
                'requestid' => $question->requestid,
                'userid' => $USER->id,
                'action' => 'question_approved',
                'component' => 'external',
                'details' => json_encode(['questionid' => $questionid, 'confidence' => $confidence]),
                'status' => 'success',
                'timecreated' => time(),
            ]);
        }

        return [
            'status' => 'approved',
        ];
    }

    /**
     * Describes the return value for approve_question.
     *
     * @return \external_single_structure
     */
    public static function approve_question_returns() {
        return new \external_single_structure([
            'status' => new \external_value(PARAM_TEXT, 'The new question status'),
        ]);
    }

    // -------------------------------------------------------------------------
    // 5. reject_question
    // -------------------------------------------------------------------------

    /**
     * Describes the parameters for reject_question.
     *
     * @return \external_function_parameters
     */
    public static function reject_question_parameters() {
        return new \external_function_parameters([
            'questionid' => new \external_value(PARAM_INT, 'The question ID', VALUE_REQUIRED),
            'reason' => new \external_value(PARAM_TEXT, 'Reason for rejection', VALUE_DEFAULT, ''),
            'feedback' => new \external_value(PARAM_TEXT, 'Additional feedback', VALUE_DEFAULT, ''),
        ]);
    }

    /**
     * Reject a question with an optional reason and feedback.
     *
     * Sets the question status to 'rejected' and logs the rejection action
     * with the provided reason and feedback.
     *
     * @param int    $questionid The question ID.
     * @param string $reason     Optional reason for rejection.
     * @param string $feedback   Optional additional feedback.
     * @return array The new status and reason.
     */
    public static function reject_question($questionid, $reason = '', $feedback = '') {
        global $DB, $USER;

        // Validate parameters.
        $params = self::validate_parameters(self::reject_question_parameters(), [
            'questionid' => $questionid,
            'reason' => $reason,
            'feedback' => $feedback,
        ]);
        $questionid = $params['questionid'];
        $reason = $params['reason'];
        $feedback = $params['feedback'];

        // Get the question record.
        $question = $DB->get_record('local_hlai_quizgen_questions', ['id' => $questionid], '*', MUST_EXIST);

        // Validate ownership.
        if ($question->userid != $USER->id) {
            throw new \moodle_exception('nopermissions', 'error');
        }

        // Validate context.
        $request = $DB->get_record('local_hlai_quizgen_requests', ['id' => $question->requestid], '*', MUST_EXIST);
        $context = \context_course::instance($request->courseid);
        self::validate_context($context);

        // Update the question status.
        $DB->set_field('local_hlai_quizgen_questions', 'status', 'rejected', ['id' => $questionid]);
        $DB->set_field('local_hlai_quizgen_questions', 'timemodified', time(), ['id' => $questionid]);

        // Log rejection with reason and feedback.
        $DB->insert_record('local_hlai_quizgen_logs', [
            'requestid' => $question->requestid,
            'userid' => $USER->id,
            'action' => 'question_rejected',
            'component' => 'external',
            'details' => json_encode([
                'questionid' => $questionid,
                'reason' => $reason,
                'feedback' => $feedback,
            ]),
            'status' => 'success',
            'timecreated' => time(),
        ]);

        return [
            'status' => 'rejected',
            'reason' => $reason,
        ];
    }

    /**
     * Describes the return value for reject_question.
     *
     * @return \external_single_structure
     */
    public static function reject_question_returns() {
        return new \external_single_structure([
            'status' => new \external_value(PARAM_TEXT, 'The new question status'),
            'reason' => new \external_value(PARAM_TEXT, 'The rejection reason'),
        ]);
    }

    // -------------------------------------------------------------------------
    // 6. bulk_approve
    // -------------------------------------------------------------------------

    /**
     * Describes the parameters for bulk_approve.
     *
     * @return \external_function_parameters
     */
    public static function bulk_approve_parameters() {
        return new \external_function_parameters([
            'questionids' => new \external_value(PARAM_RAW, 'JSON array of question IDs to approve', VALUE_REQUIRED),
        ]);
    }

    /**
     * Bulk approve multiple questions.
     *
     * Iterates through the provided question IDs and approves each one
     * that exists and is owned by the current user. Questions not owned
     * by the user are silently skipped.
     *
     * @param string $questionids JSON-encoded array of question IDs.
     * @return array The count of approved questions.
     */
    public static function bulk_approve($questionids) {
        global $DB, $USER;

        // Validate parameters.
        $params = self::validate_parameters(self::bulk_approve_parameters(), [
            'questionids' => $questionids,
        ]);
        $questionids = $params['questionids'];

        // Decode the JSON array.
        $questionids = json_decode($questionids, true);
        if (!is_array($questionids) || empty($questionids)) {
            throw new \moodle_exception('ajax_no_questions_specified', 'local_hlai_quizgen');
        }

        // Validate context using the first question's course.
        $firstqid = (int)reset($questionids);
        $firstquestion = $DB->get_record('local_hlai_quizgen_questions', ['id' => $firstqid], '*', MUST_EXIST);
        $request = $DB->get_record('local_hlai_quizgen_requests', ['id' => $firstquestion->requestid], '*', MUST_EXIST);
        $context = \context_course::instance($request->courseid);
        self::validate_context($context);

        // Approve each question owned by the current user.
        $approved = 0;
        foreach ($questionids as $qid) {
            $qid = (int)$qid;
            $question = $DB->get_record('local_hlai_quizgen_questions', ['id' => $qid]);
            if ($question && $question->userid == $USER->id) {
                $DB->set_field('local_hlai_quizgen_questions', 'status', 'approved', ['id' => $qid]);
                $DB->set_field('local_hlai_quizgen_questions', 'timemodified', time(), ['id' => $qid]);
                $approved++;
            }
        }

        return [
            'approved' => $approved,
        ];
    }

    /**
     * Describes the return value for bulk_approve.
     *
     * @return \external_single_structure
     */
    public static function bulk_approve_returns() {
        return new \external_single_structure([
            'approved' => new \external_value(PARAM_INT, 'Number of questions approved'),
        ]);
    }

    // -------------------------------------------------------------------------
    // 7. bulk_reject
    // -------------------------------------------------------------------------

    /**
     * Describes the parameters for bulk_reject.
     *
     * @return \external_function_parameters
     */
    public static function bulk_reject_parameters() {
        return new \external_function_parameters([
            'questionids' => new \external_value(PARAM_RAW, 'JSON array of question IDs to reject', VALUE_REQUIRED),
            'reason' => new \external_value(PARAM_TEXT, 'Reason for rejection', VALUE_DEFAULT, ''),
        ]);
    }

    /**
     * Bulk reject multiple questions.
     *
     * Iterates through the provided question IDs and rejects each one
     * that exists and is owned by the current user. Questions not owned
     * by the user are silently skipped.
     *
     * @param string $questionids JSON-encoded array of question IDs.
     * @param string $reason      Optional reason for rejection.
     * @return array The count of rejected questions and the reason.
     */
    public static function bulk_reject($questionids, $reason = '') {
        global $DB, $USER;

        // Validate parameters.
        $params = self::validate_parameters(self::bulk_reject_parameters(), [
            'questionids' => $questionids,
            'reason' => $reason,
        ]);
        $questionids = $params['questionids'];
        $reason = $params['reason'];

        // Decode the JSON array.
        $questionids = json_decode($questionids, true);
        if (!is_array($questionids) || empty($questionids)) {
            throw new \moodle_exception('ajax_no_questions_specified', 'local_hlai_quizgen');
        }

        // Validate context using the first question's course.
        $firstqid = (int)reset($questionids);
        $firstquestion = $DB->get_record('local_hlai_quizgen_questions', ['id' => $firstqid], '*', MUST_EXIST);
        $request = $DB->get_record('local_hlai_quizgen_requests', ['id' => $firstquestion->requestid], '*', MUST_EXIST);
        $context = \context_course::instance($request->courseid);
        self::validate_context($context);

        // Reject each question owned by the current user.
        $rejected = 0;
        foreach ($questionids as $qid) {
            $qid = (int)$qid;
            $question = $DB->get_record('local_hlai_quizgen_questions', ['id' => $qid]);
            if ($question && $question->userid == $USER->id) {
                $DB->set_field('local_hlai_quizgen_questions', 'status', 'rejected', ['id' => $qid]);
                $DB->set_field('local_hlai_quizgen_questions', 'timemodified', time(), ['id' => $qid]);
                $rejected++;
            }
        }

        return [
            'rejected' => $rejected,
            'reason' => $reason,
        ];
    }

    /**
     * Describes the return value for bulk_reject.
     *
     * @return \external_single_structure
     */
    public static function bulk_reject_returns() {
        return new \external_single_structure([
            'rejected' => new \external_value(PARAM_INT, 'Number of questions rejected'),
            'reason' => new \external_value(PARAM_TEXT, 'The rejection reason'),
        ]);
    }
}
